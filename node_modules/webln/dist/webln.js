(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.WebLN = {}));
}(this, function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /* tslint:disable:max-classes-per-file */
    /**
     * Workaround for custom errors when compiling typescript targeting 'ES5'.
     * see: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
     * @param {CustomError} error
     * @param newTarget the value of `new.target`
     * @param {Function} errorType
     */
    function fixError(error, newTarget, errorType) {
        Object.setPrototypeOf(error, errorType.prototype);
        // when an error constructor is invoked with the `new` operator
        if (newTarget === errorType) {
            error.name = newTarget.name;
            // exclude the constructor call of the error type from the stack trace.
            if (Error.captureStackTrace) {
                Error.captureStackTrace(error, errorType);
            }
            else {
                var stack = new Error(error.message).stack;
                if (stack) {
                    error.stack = fixStack(stack, "new " + newTarget.name);
                }
            }
        }
    }
    function fixStack(stack, functionName) {
        if (!stack)
            return stack;
        if (!functionName)
            return stack;
        // exclude lines starts with:  "  at functionName "
        var exclusion = new RegExp("\\s+at\\s" + functionName + "\\s");
        var lines = stack.split("\n");
        var resultLines = lines.filter(function (line) { return !line.match(exclusion); });
        return resultLines.join("\n");
    }
    /// CUSTOM ERRORS ///
    // When no WebLN provider is available
    var MissingProviderError = /** @class */ (function (_super) {
        __extends(MissingProviderError, _super);
        function MissingProviderError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return MissingProviderError;
    }(Error));
    // When the user rejects a request
    var RejectionError = /** @class */ (function (_super) {
        __extends(RejectionError, _super);
        function RejectionError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return RejectionError;
    }(Error));
    // When the node can't be connected to (i.e. the app did nothing wrong)
    var ConnectionError = /** @class */ (function (_super) {
        __extends(ConnectionError, _super);
        function ConnectionError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, ConnectionError);
            return _this;
        }
        return ConnectionError;
    }(Error));
    // The WebLN provider doesn't support this method
    var UnsupportedMethodError = /** @class */ (function (_super) {
        __extends(UnsupportedMethodError, _super);
        function UnsupportedMethodError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, UnsupportedMethodError);
            return _this;
        }
        return UnsupportedMethodError;
    }(Error));
    // The desired node couldn't be routed to
    var RoutingError = /** @class */ (function (_super) {
        __extends(RoutingError, _super);
        function RoutingError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return RoutingError;
    }(Error));
    // An argument passed was somehow invalid (e.g. malformed invoice)
    var InvalidDataError = /** @class */ (function (_super) {
        __extends(InvalidDataError, _super);
        function InvalidDataError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return InvalidDataError;
    }(Error));
    // Something broke in the WebLN provider internally, nothing to do with the app
    var InternalError = /** @class */ (function (_super) {
        __extends(InternalError, _super);
        function InternalError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            fixError(_this, _newTarget, RejectionError);
            return _this;
        }
        return InternalError;
    }(Error));

    function requestProvider(_) {
        if (_ === void 0) { _ = {}; }
        return new Promise(function (resolve, reject) {
            if (typeof window === 'undefined') {
                return reject(new Error('Must be called in a browser context'));
            }
            var webln = window.webln;
            if (!webln) {
                return reject(new MissingProviderError('Your browser has no WebLN provider'));
            }
            webln.enable()
                .then(function () { return resolve(webln); })
                .catch(function (err) { return reject(err); });
        });
    }

    exports.requestProvider = requestProvider;
    exports.MissingProviderError = MissingProviderError;
    exports.RejectionError = RejectionError;
    exports.ConnectionError = ConnectionError;
    exports.UnsupportedMethodError = UnsupportedMethodError;
    exports.RoutingError = RoutingError;
    exports.InvalidDataError = InvalidDataError;
    exports.InternalError = InternalError;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
